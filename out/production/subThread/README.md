# 死锁
    不同的线程分别占用对方需要的同步资源不放弃,都在等对方放弃自己需要的同步资源,就形成了线程的死锁
    出现死锁后,不会出现异常,不会出现提示,只是所有的线程都处于阻塞状态,无法继续.

# 解决方法
    1.专门的算法、原则
    2.尽量减少同步资源的定义
    3.尽量避免嵌套同步

# synchronized和lock的异同
    相同:二者都可以解决线程安全的问题
    不同:synchronized自动,synchronized机制在执行完相应的同步代码之后,自动的释放同步监视器
         lock手动,需要手动的启动同步,同时结束同步也需要手动的实现.

### 优先使用顺序
    lock-->同步代码块(已经进入了方法体,分配了相应资源)-->同步方法(在方法体外)

# 如何解决线程安全问题?几种方式
    1、lock
    2、synchronized
        1）、同步代码块(已经进入了方法体,分配了相应资源)
        2）、同步方法(在方法体外)


若有共享数据，会产生线程安全问题。
--------------------------------------------------

# 线程的通信

# sleep()和wait()方法的异同:
    相同点:一旦执行方法,都可以使得当前的线程进入阻塞状态
    不同点:
        1）两个方法声明的位置不同，Thread类中声明sleep，object类中声明wait
        2)调用的范围不同.sleep可以在任何需要的场景下调用。wait方法必须使用在同步代码块或者同步方法中。
        3）有关于是否释放同步监视器：如果两个方法都是用在同步代码块或者同步方法中，sleep不会释放锁，wait会释放锁(即同步监视器)

![image-20201002122531961](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201002122531961.png)


